Notes on implementation choices
===============================


How to access values inside fields?
-----------------------------------

For example, given a 64-bit word, a 32-bit integer in the second half could be accessed by
either shifting, or by type-thunking a pointer (a ulong* to an int*). The pointer could be
to a *coopy* of the value on the stack, or we could *fix* the field and use a pointer to
the field directly. There's only one way to know for sure: fight!

With:

            public int ValueShift {
                get { return unchecked((int)(word >> 32)); } }
            public unsafe int ValueUnsafeCopy {
                get { var v = word; return ((int*)&v)[1]; } }
            public unsafe int ValueUnsafeFixed {
                get { fixed(ulong* p = &word) { return ((int*)p)[1]; } } }

I get the results below; from this, I'm declaring shifting to be optimal, while also having
the advantage of being more applicable to contexts that do not allow unsafe; win/win.

The first number is the count, which is the number of iterations over an array of 1024 values.
Note that "chk" is an xor over all the successive terms in the loop, to prove all implementations
are producing the same result.

Shift: 1048576 in 2138ms; chk: 1543101091
UnsafeCopy: 1048576 in 4510ms; chk: 1543101091
UnsafeFixed: 1048576 in 7001ms; chk: 1543101091

Shift: 1048576 in 2141ms; chk: 1543101091
UnsafeCopy: 1048576 in 4500ms; chk: 1543101091
UnsafeFixed: 1048576 in 7004ms; chk: 1543101091

Shift: 1048576 in 2135ms; chk: 1543101091
UnsafeCopy: 1048576 in 4481ms; chk: 1543101091
UnsafeFixed: 1048576 in 6978ms; chk: 1543101091

Shift: 1048576 in 2129ms; chk: 1543101091
UnsafeCopy: 1048576 in 4491ms; chk: 1543101091
UnsafeFixed: 1048576 in 6994ms; chk: 1543101091

Shift: 1048576 in 2140ms; chk: 1543101091
UnsafeCopy: 1048576 in 4507ms; chk: 1543101091
UnsafeFixed: 1048576 in 6992ms; chk: 1543101091